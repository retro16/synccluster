#!/bin/bash

###############################################################################
<<LICENSE

The MIT License (MIT)

Copyright (c) 2016 Jean-Matthieu COULON

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

LICENSE
###############################################################################

SYNCCLUSTER_VERSION="10002" # major * 10000 + minor
SELF="$0"
SCRIPT="$(readlink -fs "$SELF")"
SCRIPTNAME="$(basename "$SCRIPT")"
ARGS=("$@")
[ "$FLOCKER" != "$SCRIPT" ] && exec env FLOCKER="$SCRIPT" flock -e -w 1 "$SCRIPT" "$SCRIPT" "${ARGS[@]}" || :

set -e
[ "$SYNCCLUSTER_DEBUG" ] && set -x

unset ROLE
unset MASTER
unset MASTER_USER
unset DATADIR
unset KODIDIR
unset CLOUDDIR
unset WWWDIR
unset BACKUPDIR
unset MAILDIR
unset UNISON
unset DOMAIN
unset MAILRELAY

# Load settings

# Generate a synccluster file suitable for a new master
default_synccluster() {
  cat <<EOF
ROLE=''
MASTER='$MASTER'
MASTER_USER='$MASTER_USER'
DATADIR='/home/.local'
KODIDIR='/home/.local/kodi'
CLOUDDIR='/home/.local/cloud'
WWWDIR='/var/www'
BACKUPDIR='/home/.local/backup'
MAILDIR='/var/mail'
UNISON='/home/.local/unison'
MIRROR='$MIRROR'
DISTNAME='$DISTNAME'
DOMAIN='$DOMAIN'
MAILRELAY='$MAILRELAY'
EOF
}

current_synccluster() {
  cat <<EOF
ROLE='$ROLE'
MASTER='$MASTER'
MASTER_USER='$MASTER_USER'
DATADIR='$DATADIR'
KODIDIR='$KODIDIR'
CLOUDDIR='$CLOUDDIR'
WWWDIR='$WWWDIR'
BACKUPDIR='$BACKUPDIR'
MAILDIR='$MAILDIR'
UNISON='$UNISON'
MIRROR='$MIRROR'
DISTNAME='$DISTNAME'
DOMAIN='$DOMAIN'
MAILRELAY='$MAILRELAY'
EOF
}

MIRROR="$(grep -E '^deb [hft]*tp://.*debian.* main' /etc/apt/sources.list | head -n 1 | sed 's;deb \([^ ]*\) [a-z/]* main.*;\1;')"
DISTNAME="$(grep -E '^deb [hft]*tp://.*debian.* main' /etc/apt/sources.list | head -n 1 | sed 's;deb [^ ]* \([a-z/]*\) main.*;\1;')"
eval "$(default_synccluster)"
[ -e "/etc/default/$SCRIPTNAME" ] && . /etc/default/$SCRIPTNAME

export PASSWORD=''
export ROLE
export MASTER
export MASTER_USER
export DATADIR
export KODIDIR
export CLOUDDIR
export WWWDIR
export BACKUPDIR
export MAILDIR
export UNISON
export MIRROR
export DISTNAME
export DOMAIN
export MAILRELAY


export roundcube_version="1.1.4"
export owncloud_version="9.0.0"
export roundcube_url="http://downloads.sourceforge.net/project/roundcubemail/roundcubemail/$roundcube_version/roundcubemail-$roundcube_version-complete.tar.gz"
export owncloud_url="https://download.owncloud.org/community/owncloud-${owncloud_version}.tar.bz2"
export cygwin_url="https://cygwin.com/setup-x86_64.exe"
export cygwin_mirror="http://mirror.switch.ch/ftp/mirror/cygwin"
export cygwin_install_dir="C:\\cygwin_$SCRIPTNAME"
export cygwin_packages="bash,wget,rsync,unison"
export cygwin_install_command="setup-x86_64.exe -D -R $cygwin_install_dir -s $cygwin_mirror -P $cygwin_packages -a x86_64 -q -B -l $cygwin_install_dir\\install -N -d"

[ "$(uname -o)" = "Cygwin" ] && cygwin=1 || cygwin=""

lock="/var/lock/$SCRIPTNAME"

version() {
  echo "$SYNCCLUSTER_VERSION"
}

update_from_master() {
  [ "$MASTER" ] || return
  local remote_version="$(master_exec version)"
  if [ "$remote_version" ] && [ "$remote_version" -gt "$(version)" ]; then
    if [ -w "$SCRIPT" ]; then
      local tmpfile="$(mktemp)"
      trap "rm -f '$tmpfile'" EXIT
      master_exec 'cat "$(which "$SCRIPTNAME")"' > "$tmpfile"
      mv "$tmpfile" "$SCRIPT"
      chmod 755 "$SCRIPT"
      trap EXIT
      if [ "${ARGS[0]}" != "update_from_master" ]; then
        # We were in an implicit call, restart the command with the updated script
        "$SCRIPT" "${ARGS[@]}"
        exit $?
      fi
    else
      echo "Warning: the local script does not have the same version as the master" >&2
    fi
  elif [ "$remote_version" ] && [ "$remote_version" -gt "$(version)" ]; then
    echo "Warning: master server $MASTER has an older version of $SCRIPTNAME"
  fi
}

require_domain() {
  [ "$DOMAIN" ] || DOMAIN="$1"
  [ "$DOMAIN" ] || DOMAIN="$(dnsdomainname)"
  [ "$DOMAIN" ] || read -p 'Enter domain name:' DOMAIN
}

require_mailrelay() {
  [ "$MAILRELAY" ] || MAILRELAY="$1"
  [ "$MAILRELAY" ] || read -p 'Enter e-mail relay host:' MAILRELAY
}

generate_synccluster_conf() {
  local synccluster="$1"; [ "$synccluster" ] || synccluster="/etc/default/$SCRIPTNAME"; shift || true
  require_domain
  case "$ROLE" in
    master|standby|secondary)
      require_mailrelay
      ;;
  esac
  current_synccluster > "$synccluster"
  . "$synccluster"
}

require_master_conf() {
  if [ "$ROLE" != "master" ]; then
    eval "$(ssh "$MASTER_USER" "cat /etc/default/$SCRIPTNAME" | sed 's;^;M_;')"
  else
    eval "$(current_synccluster | sed 's;^;M_;')"
  fi
}

default_roundcube_conf() {
  require_password
  cat <<EOF
<?php
\$config = array();
\$config['language'] = 'fr_FR';
\$config['smtp_debug'] = false;
\$config['imap_debug'] = false;
\$config['log_logins'] = false;
\$config['log_session'] = false;
\$config['db_dsnw'] = 'pgsql://roundcubemail:${PASSWORD}roundcubemail@127.0.0.1/roundcubemail'

\$config['default_host'] = '$DOMAIN';
\$config['default_port'] = 143;
\$config['imap_auth_type'] = 'PLAIN';

\$config['smtp_server'] = '$DOMAIN';
\$config['smtp_port'] = 25;
\$config['smtp_user'] = '%u';
\$config['smtp_pass'] = '%p';
\$config['smtp_auth_type'] = 'PLAIN';

\$config['support_url'] = '';
\$config['product_name'] = 'Roundcube Webmail';
\$config['des_key'] = '9j!eitu()""@551hdkcoeoze';

\$config['plugins'] = array(
    'archive',
    'zipdownload',
    'carddav',
);

\$config['skin'] = 'larry';
EOF
}

require_password() {
  if [ -z "$PASSWORD" ]; then
    p1=a
    p2=b
    while [ "$p1" != "$p2" ]; do
      read -p "Enter master password:" -s p1
      echo ''
      read -p "Confirm master password:" -s p2
      echo ''
      [ "$p1" = "$p2" ] || echo "Passwords do not match, please try again"
    done
    PASSWORD="$p1"
  fi
}

git_get() {
  local url="$1"
  local target="$2"
  if [ -d "$target/.git" ]; then
    pushd "$target" &>/dev/null
    git clean -dfx
    git pull
    popd &>/dev/null
  elif [ -d "$target" ]; then
    rm -rf "$target"
    git clone "$url" "$target"
  else
    git clone "$url" "$target"
  fi
}

setup_sudo() {
  require_packages sudo

  cat >> /etc/sudoers <<EOF
root   ALL=NOPASSWD: ALL
%sudo   ALL=NOPASSWD: ALL
EOF
}

install_roundcube() {
  require_password
  require_apache_php
  require_postgresql
  [ -e /tmp/roundcube.tar.gz ] || wget -O/tmp/roundcube.tar.gz "$roundcube_url"
  rm -rf "$WWWDIR/roundcubemail-$roundcube_version" "$WWWDIR/roundcubemail"
  tar -C "$WWWDIR" -xvzf /tmp/roundcube.tar.gz
  ln -fs "roundcubemail-$roundcube_version" "$WWWDIR/roundcubemail"
  pushd "$WWWDIR" &>/dev/null
  su -c 'psql -c "DROP DATABASE IF EXISTS roundcubemail;"' postgres
  su -c 'psql -c "DROP ROLE IF EXISTS roundcubemail";' postgres
  su -c 'psql -c "CREATE USER roundcubemail WITH PASSWORD '\'"${PASSWORD}roundcubemail"\'';"' postgres
  su -c 'psql -c "CREATE DATABASE roundcubemail OWNER=roundcubemail;"' postgres
  PGPASSWORD="${PASSWORD}roundcubemail" psql -U roundcubemail -h localhost -p 5432 roundcubemail < "$WWWDIR/roundcubemail/SQL/postgres.initial.sql"
  git_get https://github.com/blind-coder/rcmcarddav.git "$WWWDIR/plugins/carddav"
  default_roundcube_conf > "$WWWDIR/roundcubemail/config/config.inc.php"
  chown -R www-data:www-data "$WWWDIR/roundcubemail/logs"
  chown -R www-data:www-data "$WWWDIR/roundcubemail/temp"
  rm /tmp/roundcube.tar.gz
  popd &>/dev/null
}

default_postfix_conf() {
  cat <<EOF
alias_database = hash:/etc/aliases
alias_maps = hash:/etc/aliases
append_dot_mydomain = no
biff = no
config_directory = /etc/postfix
inet_interfaces = all
mailbox_command = procmail -f- -a "\$USER"
mailbox_size_limit = 0
mydestination = $DOMAIN, localhost
myhostname = $DOMAIN
mynetworks = 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128
myorigin = /etc/mailname
readme_directory = no
recipient_delimiter = +
relayhost = $MAILRELAY
smtp_tls_session_cache_database = btree:\${data_directory}/smtp_scache
smtpd_banner = \$myhostname ESMTP \$mail_name (Debian/GNU)
smtpd_relay_restrictions = permit_mynetworks permit_sasl_authenticated reject_unauth_destination
smtpd_sasl_auth_enable = yes
smtpd_sasl_authenticated_header = yes
smtpd_sasl_local_domain = \$myorigin
smtpd_sasl_path = private/auth
smtpd_sasl_security_options = noanonymous
smtpd_sasl_type = dovecot
smtpd_tls_cert_file = /etc/ssl/certs/ssl-cert-snakeoil.pem
smtpd_tls_key_file = /etc/ssl/private/ssl-cert-snakeoil.key
smtpd_tls_session_cache_database = btree:\${data_directory}/smtpd_scache
smtpd_use_tls = yes
EOF
}

default_procmail_conf() {
  cat <<EOF
UMASK=007
DEFAULT=\${EPREFIX}$MAILDIR/\$LOGNAME/Maildir/
EOF
}

install_postfix() {
  require_packages postfix
  local target="$1"; [ "$target" ] || target="/etc/postfix"; shift || true
  if [ -e "$target/main.cf" ]; then
    mv "$target/main.cf" "$target/main.cf.old"
  fi
  require_mailrelay
  require_domain
  default_postfix_conf > "$target/main.cf"
  default_procmail_conf > "/etc/procmailrc"
  echo "$DOMAIN" > /etc/mailname
  [ -d "$MAILDIR" ] || mkdir -p "$MAILDIR"
  chmod 1777 "$MAILDIR"
  systemctl restart postfix
}

default_dovecot_conf() {
  cat <<EOF
disable_plaintext_auth = no
mail_privileged_group = mail
mail_home = $MAILDIR/%u
mail_location = maildir:$MAILDIR/%u/Maildir:LAYOUT=fs
userdb {
  driver = passwd
}
passdb {
  args = %s
  driver = pam
}
protocols = "imap"
protocol imap {
}
plugin {
  autocreate = Trash
  autocreate2 = Sent
  autosubscribe = Trash
  autosubscribe2 = Sent
}
service auth {
  unix_listener /var/spool/postfix/private/auth {
    group = postfix
    mode = 0660
    user = postfix
  }
}
auth_mechanisms = plain login
ssl = yes
ssl_cert = </etc/ssl/certs/ssl-cert-snakeoil.pem
ssl_key = </etc/ssl/private/ssl-cert-snakeoil.key
ssl_cipher_list = ALL:!LOW:!SSLv2:ALL:!aNULL:!ADH:!eNULL:!EXP:RC4+RSA:+HIGH:+MEDIUM
EOF
}

install_dovecot() {
  require_packages dovecot-imapd
  local target="$1"; [ "$target" ] || target="/etc/dovecot"; shift || true
  if [ -e "$target/dovecot.conf" ]; then
    mv "$target/dovecot.conf" "$target/dovecot.conf.old"
  fi
  default_dovecot_conf > "$target/dovecot.conf"
  systemctl restart dovecot
}

install_owncloud() {
  require_password
  require_apache_php
  require_postgresql
  [ -e /tmp/owncloud.tar.bz2 ] || wget -O/tmp/owncloud.tar.bz2 "$owncloud_url"
  rm -rf "$WWWDIR/owncloud"
  dir "$CLOUDDIR"
  tar -C "$WWWDIR" -xvjf /tmp/owncloud.tar.bz2
  chown -R www-data:www-data "$WWWDIR/owncloud/apps"
  chown -R www-data:www-data "$WWWDIR/owncloud/config"
  chown -R www-data:www-data "$CLOUDDIR"
  chown -R www-data:www-data "$WWWDIR/owncloud/themes"
  pushd "$WWWDIR/owncloud" &>/dev/null
  su -c 'psql -c "DROP DATABASE IF EXISTS owncloud;"' postgres
  su -c 'psql -c "DROP ROLE IF EXISTS owncloud";' postgres
  su -c 'psql -c "CREATE USER owncloud WITH PASSWORD '\'"${PASSWORD}owncloud"\'';"' postgres
  su -c 'psql -c "CREATE DATABASE owncloud OWNER=owncloud;"' postgres
  trap "sed -i 's;^\\(www-data:.*:\\).*;\\1/usr/sbin/nologin;' /etc/passwd" EXIT
  sed -i 's;^\(www-data:.*:\).*;\1/bin/bash;' /etc/passwd
  su -c "php occ maintenance:install --database pgsql --database-name owncloud --database-host localhost --database-user owncloud --database-pass ${PASSWORD}owncloud --admin-user admin --admin-pass ${PASSWORD}admin --data-dir $CLOUDDIR" www-data
  git_get "https://github.com/owncloud/contacts.git" "$WWWDIR/owncloud/apps/contacts"
  chown -R root:www-data "$CLOUDDIR/.htaccess"
  chown -R root:www-data "$WWWDIR/owncloud/.htaccess"
  su -c "$WWWDIR/owncloud/occ app:enable external" www-data
  su -c "$WWWDIR/owncloud/occ app:enable files_external" www-data
  su -c "$WWWDIR/owncloud/occ app:enable user_external" www-data
  su -c "$WWWDIR/owncloud/occ app:enable contacts" www-data
  head -n -1 "$WWWDIR/owncloud/config/config.php" > /tmp/config.php
  cat >> /tmp/config.php <<EOF
  'memcache.local' => '\\\\OC\\\\Memcache\\\\APCu',
  'user_backends' => 
  array (
    0 => 
    array (
      'class' => 'OC_User_IMAP',
      'arguments' => 
      array (
        0 => '{localhost:143/imap/tls/novalidate-cert}INBOX',
      ),
    ),
  ),
);
EOF
  sed -i "s/    0 => 'localhost',/    0 => '$DOMAIN',/" /tmp/config.php
  chown www-data:www-data /tmp/config.php
  mv /tmp/config.php "$WWWDIR/owncloud/config/config.php"
  sed -i 's;^\(www-data:.*:\).*;\1/usr/sbin/nologin;' /etc/passwd
  trap EXIT
  rm /tmp/owncloud.tar.bz2
  popd &>/dev/null
}

restore_master() {
  local host="$(hostname -f)"
  local src="$1"; [ "$src" ] || src="$BACKUPDIR/$host"; shift || true

  if [ "${src#*:}" = "$src" ] && ! [ -d "$src" ]; then
    echo "Cannot find source directory $src"
    exit 1
  fi

  local skip_setup_master=''
  if grep "MASTER=''" "/etc/default/$SCRIPTNAME" &>/dev/null; then
    skip_setup_master=1
  fi

  if [ "${src#*:}" != "$src" ]; then
    unset MASTER
    unset MASTER_USER
    require_packages rsync
    require_master "${src%%:*}"
    upload_ssh_key
    fetch_master_conf
  else
    fetch_backup_conf "$src/fs/etc/default/$SCRIPTNAME"
  fi

  ROLE=master
  generate_synccluster_conf

  # Setup this machine as a master
  [ "$skip_setup_master" ] || setup_master

  echo "Restoring data from $src ..."
  
  generate_backup_rsync_list > "/tmp/rsync_list"

  # Restore users
  mkdir /tmp/newusers
  rsync -a "$src/fs/etc/{passwd,shadow,group}" /tmp/newusers
  grep -E ':x:100[0-9][0-9]:' /tmp/newusers/passwd >> /etc/passwd
  grep -E ':x:100[0-9][0-9]:' /tmp/newusers/group >> /etc/group
  grep -E ':x:100[0-9][0-9]:' /tmp/newusers/passwd | while IFS=':' read user pass uid gid name homedir shell; do
    grep -E "^$user:" /tmp/newusers/shadow >> /etc/shadow
    if ! [ -d "$homedir" ]; then
      cp -a /etc/skel "$homedir"
      chown -R "$uid:$gid" "$homedir"
    fi
  done
  rm -r /tmp/newusers

  # Restore database
  rsync -aP --include-from="/tmp/rsync_list" "$src/fs/" "/"
  if [ "${src#*:}" != "$src" ]; then
    ssh "$MASTER_USER" "[ -e '${src#*:}/postgres.xz' ]" && ssh "$MASTER_USER" "cat '${src#*:}/postgres.xz'" | su -c "unxz -c | grep -Pv '^(?:CREATE|DROP|ALTER) ROLE postgres' | psql" postgres
  elif [ -e "$src/postgres.xz" ]; then
    su -c "unxz -c | grep -Pv '^(?:CREATE|DROP|ALTER) ROLE postgres' | psql" postgres < "$src/postgres.xz"
  fi
}

generate_backup_rsync_list() {
  cat <<EOF
- *.o
- .*.swp
- [cC]ache/
- .[cC]ache/
- [lL]ock
- .parentlock
- *.nps
- *~
- .*~
- .[tT]rash*
- [tT]humbs.db
- \$RECYCLE.BIN
- Crash Reports
- /**/Documents/HTC/**
+ /etc
+ /etc/apt
+ /etc/apt/sources.list.d
+ /etc/apt/sources.list.d/**
+ /etc/aliases
+ /etc/mailname
+ /etc/cron.d
+ /etc/cron.d/**
+ $CLOUDDIR
+ $CLOUDDIR/**
+ $KODIDIR
+ $KODIDIR/**
+ $WWWDIR
+ $WWWDIR/**
+ $MAILDIR
+ $MAILDIR/**
+ $UNISON
+ $UNISON/**
+ /home
+ /home/[a-zA-Z0-9]*
+ /home/[a-zA-Z0-9]*/Bureau
+ /home/[a-zA-Z0-9]*/Bureau/**
+ /home/[a-zA-Z0-9]*/Documents
+ /home/[a-zA-Z0-9]*/Documents/**
+ /home/[a-zA-Z0-9]*/Images
+ /home/[a-zA-Z0-9]*/Images/**
+ /home/[a-zA-Z0-9]*/Modèles
+ /home/[a-zA-Z0-9]*/Modèles/**
+ /home/[a-zA-Z0-9]*/Musique
+ /home/[a-zA-Z0-9]*/Musique/**
+ /home/[a-zA-Z0-9]*/Vidéos
+ /home/[a-zA-Z0-9]*/Vidéos/**
+ /home/[a-zA-Z0-9]*/Jeux
+ /home/[a-zA-Z0-9]*/Jeux/**
+ /home/[a-zA-Z0-9]*/Logiciels
+ /home/[a-zA-Z0-9]*/Logiciels/**
+ /home/[a-zA-Z0-9]*/.config
+ /home/[a-zA-Z0-9]*/.config/**
+ /home/[a-zA-Z0-9]*/.mozilla
+ /home/[a-zA-Z0-9]*/.mozilla/**
+ /home/[a-zA-Z0-9]*/.vimrc
+ /home/[a-zA-Z0-9]*/.vim
+ /home/[a-zA-Z0-9]*/.vim/**
+ /home/[a-zA-Z0-9]*/.ssh
+ /home/[a-zA-Z0-9]*/.ssh/**
+ /home/[a-zA-Z0-9]*/.unison
+ /home/[a-zA-Z0-9]*/.unison/*.prf
+ /home/[a-zA-Z0-9]*/.procmailrc
+ /usr
+ /usr/local
+ /usr/local/**
+ /var
+ /var/spool
+ /var/spool/cron
+ /var/spool/cron/crontabs*
+ /var/spool/cron/crontabs*/*
+ /var/www
+ /var/www/*
+ /var/www/*/config
+ /var/www/*/config/**
+ /opt
+ /opt/**
- *
EOF
}

change_hostname() {
  local new="$1"
  local current="$(hostname -f)"

  require_root
  require_domain

  local newdomain="${new#*.}"
  local newhost="${new%%.*}"
  
  if [ "$DOMAIN" != "$newdomain" ]; then
    # Update domain name
    #  update config files
    sed -i "/config.*'default_host'/s/'$DOMAIN'/'$newdomain'/" "$WWWDIR/roundcubemail/config/config.inc.php"
    sed -i "/config.*'smtp_server'/s/'$DOMAIN'/'$newdomain'/" "$WWWDIR/roundcubemail/config/config.inc.php"
    sed -i "/0 => '/s/'$DOMAIN'/'$newdomain'/" "$WWWDIR/owncloud/config/config.php"
    sed -i "s/^myhostname *=/myhostname = $newdomain" "/etc/postfix/main.cf"
    sed -i "s/^mydestination *=/mydestination = $newdomain, localhost" "/etc/postfix/main.cf"

    #  update drive labels
    pushd /etc/disk/by-label &>/dev/null
    
    local tmpdir="$(mktemp -d)"
    trap "umount -l '$tmpdir'; rmdir '$tmpdir'" EXIT

    for label in "${DOMAIN}="*; do
      mount -o subvol=/ "/dev/disk/by-label/$label" "$tmpdir"
      newlabel="$newdomain=${label#*=}"
      btrfs filesystem label "$newlabel" "$tmpdir"
      sed -i "s/^LABEL=$label /LABEL=$newlabel /" "$tmpdir/fstab"
      umount "$tmpdir"
    done

    rmdir "$tmpdir"
    trap EXIT
    popd &>/dev/null

    DOMAIN="newdomain"
    generate_synccluster_conf
  fi

  # Update host name
  sed -i "s;^127\.0\.1\.1.*$current;127.0.1.1 $new $newhost;" /etc/hosts
  echo "$newhost" > /etc/hostname
 
  echo "You need to reboot for the changes to take effect."
}

backup() {
  local host="$(hostname -f)"
  local src="$1"; [ "$src" ] || src="/"; shift || true
  local target="$1"; [ "$target" ] || target="$BACKUPDIR/$host"; shift || true

  dir "$target/fs"

  # Create remote backup directory
  unset MASTER
  unset MASTER_USER
  if [ "${target#*:}" != "$target" ]; then
    require_master "${target%%:*}"
    upload_ssh_key
    ssh "$MASTER_USER" "[ -d '${target#*:}/fs' ] || mkdir -p '${target#*:}/fs'"
  elif [ "${src#*:}" != "$src" ]; then
    require_master "${src%%:*}"
    upload_ssh_key
  fi

  # Synchronize files
  generate_backup_rsync_list > "/tmp/rsync_list"
  rsync -aP --delete --delete-excluded --include-from="/tmp/rsync_list" "$src/" "$target/fs/"

  # Backup the database
  pushd / &>/dev/null
  if [ "${src#*:}" != "$src" ]; then
    ssh "$MASTER_USER" \
      "cd /; which pg_dumpall &>/dev/null && su -c 'pg_dumpall -c | xz -c -8 -e' postgres" > "$target/postgres.xz"
    echo "Last successful backup at $(date)" > "$target/last_success"
  elif [ "${target#*:}" != "$target" ]; then
    su -c 'pg_dumpall -c | xz -c -8 -e' postgres | ssh "$MASTER_USER" "cat > '${target#*:}/postgres.xz'"
    ssh "$MASTER_USER" 'echo "Last successful backup at $(date)" > "$target/last_success"'
  else
    su -c 'pg_dumpall -c | xz -c -8 -e' postgres > "$target/postgres.xz"
    echo "Last successful backup at $(date)" > "$target/last_success"
  fi
  popd &>/dev/null
}


generate_apache_conf() {
  local target="$1"; [ "$target" ] || target="/etc/apache2"; shift || true
  cat > "$target"/conf-available/roundcubemail-local.conf <<EOF
Alias /mail "$WWWDIR/roundcubemail/"

<Directory "$WWWDIR/roundcubemail">
    Options +FollowSymLinks
    AllowOverride All

    SetEnv HOME $WWWDIR/roundcubemail
    SetEnv HTTP_HOME $WWWDIR/roundcubemail
</Directory>
EOF
  ln -fs ../conf-available/roundcubemail-local.conf "$target"/conf-enabled/roundcubemail-local.conf

  cat > "$target"/conf-available/owncloud-local.conf <<EOF
Alias /cloud "$WWWDIR/owncloud/"
Redirect 301 /owncloud /cloud

<Directory "$WWWDIR/owncloud">
    Options +FollowSymLinks
    AllowOverride All

    <IfModule mod_dav.c>
      Dav off
    </IfModule>

    SetEnv HOME $WWWDIR/owncloud
    SetEnv HTTP_HOME $WWWDIR/owncloud
</Directory>

<Directory "$CLOUDDIR/">
  # just in case if .htaccess gets disabled
  Require all denied
</Directory>

Redirect 301 /.well-known/carddav /cloud/remote.php/carddav
Redirect 301 /.well-known/caldav  /cloud/remote.php/caldav
EOF
  ln -fs ../conf-available/owncloud-local.conf "$target"/conf-enabled/owncloud-local.conf

  cat > "$target"/conf-available/transmission-local.conf <<EOF
ifmodule mod_proxy.c>
  ProxyRequests Off
  <proxy *>
    AddDefaultCharset off
    Order Allow,Deny
    Allow from all
  </proxy>

  ProxyPass /transmission http://localhost:9091/transmission
  ProxyPassReverse /transmission http://localhost:9091/transmission
  # Line below is optional
  #Redirect permanent /transmission https://myserver.com/transmission/web/

  ProxyVia On
</ifmodule>
EOF
  ln -fs ../conf-available/transmission-local.conf "$target"/conf-enabled/transmission-local.conf
}

update_php_ini() {
  local target="$1"; [ "$target" ] || target=/etc/php5/apache2/php.ini; shift || true
  sed -i 's/[ ;]*max_execution_time *= .*/max_execution_time = 600/' "$target"
  sed -i 's/[ ;]*memory_limit *= .*/memory_limit = 256M/' "$target"
  sed -i 's/[ ;]*post_max_size *= .*/post_max_size = 64M/' "$target"
  sed -i 's/[ ;]*upload_max_filesize *= .*/upload_max_filesize = 2048M/' "$target"
  sed -i 's/[ ;]*date.timezone *= .*/date.timezone = Europe\/Paris/' "$target"
  sed -i 's/[ ;]*upload_max_filesize *= .*/upload_max_filesize = 2048M/' "$target"
}

dir() {
  [ -e "$1" ] || mkdir -p "$1"
}

shell() {
  /bin/bash -i
}

require_packages() {
  if ! dpkg-query -W "$@" &>/dev/null; then
    require_root
    DEBIAN_FRONTEND=noninteractive apt-get install -y "$@"
  fi
}

chroot_setup() {
  TARGET="$1"
  shift || true
  if [ -e "$TARGET/var/log/bootstrap.log" ]; then
    return
  fi
  if ! which debootstrap &>/dev/null; then
    require_packages debootstrap
  fi
  debootstrap "$DISTNAME" "$TARGET" "$MIRROR"
}

fakechroot_setup() {
  TARGET="$1"
  shift || true
  if [ -e "$TARGET/var/log/bootstrap.log" ]; then
    return
  fi
  require_packages debootstrap fakechroot fakeroot

  fakechroot fakeroot debootstrap --variant=fakechroot "$DISTNAME" "$TARGET" "$MIRROR"
}

enter_chroot() {
    target="$1"
    shift || true
    cp "$SELF" "$target/$SCRIPTNAME"
    chmod a+x "$target/$SCRIPTNAME"
    trap "umount -l '$target/proc';umount -l '$target/sys';umount -l '$target/dev'" EXIT
    mount --rbind "/proc" "$target/proc"
    mount --rbind "/sys" "$target/sys"
    mount --rbind "/dev" "$target/dev"
    chroot "$target" /bin/bash "/$SCRIPTNAME" "$@"
    exit $?
}

enter_fakechroot() {
    target="$1"
    shift || true
    cp "$SELF" "$target/$SCRIPTNAME"
    chmod a+x "$target/$SCRIPTNAME"
    fakechroot fakeroot chroot "$target" /bin/bash "/$SCRIPTNAME" "$@"
    exit $?
}
 
if [ "${1%%=*}" = "--chroot" ]; then
  target="${1#*=}"
  shift || true

  if [ "$UID" -ne 0 ]; then
    echo "chroot mode needs to be root."
    exit 1
  fi

  chroot_setup "$target"
  enter_chroot "$target" "${ARGS[@]}"
elif [ "${1%%=*}" = "--fakechroot" ]; then
  target="${1#*=}"
  shift || true

  fakechroot_setup "$target"
  enter_fakechroot "$target" "${ARGS[@]}"
fi

add_apt_sources() {
cat > /etc/apt/sources.list.d/backports.list << EOF
deb $MIRROR $DISTNAME-backports main contrib non-free
deb-src $MIRROR $DISTNAME-backports main contrib non-free
EOF
cat > /etc/apt/sources.list.d/contrib.list << EOF
deb $MIRROR $DISTNAME contrib non-free
deb-src $MIRROR $DISTNAME contrib non-free
EOF
}

install_base_packages() {
add_apt_sources
apt-get update
require_packages \
  rsync \
  unison \
  git \
  bzip2 \
  xz-utils \
  ssh \
  libnss-mdns \
  avahi-daemon \
  ntp
}

install_synccluster_client_sync() {
  cat > /etc/systemd/system/synccluster_client_sync.service <<EOF
[Unit]
Description=Refreshes client configuration from server
After=network-online.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/synccluster client_sync
User=root
Group=root

[Install]
WantedBy=multi-user.target
EOF
  systemctl daemon-reload
  systemctl enable synccluster_client_sync.service
}

install_upnpc() {
  require_packages miniupnpc
  # Let's dig holes in the router !
  cat > /etc/systemd/system/upnpc_refresh.service <<EOF
[Unit]
Description=Punches holes through NAT using UPnP
After=network-online.target

[Service]
Type=oneshot
ExecStart=/usr/bin/upnpc -r 22 tcp 25 tcp 80 tcp 143 tcp 443 tcp 993 tcp
User=root
Group=root

[Install]
WantedBy=multi-user.target
EOF
  cat > /etc/systemd/system/upnpc_refresh.timer <<EOF
[Unit]
Description=Periodically update UPnP redirections

[Timer]
OnBootSec=2min
OnCalendar=*:0/10
Persistent=true

[Install]
WantedBy=timers.target
EOF
  systemctl daemon-reload
  systemctl enable upnpc_refresh.timer
}

install_modem() {
  MODEM="$(ip route | awk '/^default/ { print $3 }')"
  if wget -qO- "http://$MODEM"|grep '/goform/WebUiLanguageSelect' &>/dev/null; then
    cat > /etc/systemd/system/update_modem.service <<EOF
[Unit]
Description=Refresh MODEM settings
After=network-online.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/update_modem
User=root
Group=root

[Install]
WantedBy=multi-user.target
EOF
    cat > /etc/systemd/system/update_modem.timer <<EOF
[Unit]
Description=Periodically update MODEM settings

[Timer]
OnBootSec=2min
OnCalendar=daily
Persistent=true

[Install]
WantedBy=timers.target
EOF
    systemctl daemon-reload
    systemctl enable update_modem.timer

    cat > /usr/local/bin/update_modem <<'EOF'
#!/bin/bash

if [ "$1" = "--help" ]; then
  echo "$0 [IP]"
  echo "Updates LaBox settings on given IP address"
  echo "If IP is omitted, uses default gateway IP"
fi

MODEM="$1"

if [ -z "$MODEM" ]; then
  MODEM="$(ip route | awk '/^default/ { print $3 }')"
fi

wget -qO/dev/null --header="Content-Type: application/x-www-form-urlencoded" --post-data="loginUsername=admin&loginPassword=password" http://"$MODEM"/goform/login

wget -qO/dev/null --header="Content-Type: application/x-www-form-urlencoded" --post-data="RgLanIpAddress0=192&RgLanIpAddress1=168&RgLanIpAddress2=0&RgLanIpAddress3=1&RgDhcpServer=1&RgDhcpStartingIpAddress3=10&RgDhcpEndingIpAddress3=50&RgDhcpLeaseDuration=86400" http://"$MODEM"/goform/WebUiRgLanParam

wget -qO/dev/null --header="Content-Type: application/x-www-form-urlencoded" --post-data="RgWiFiService=1&RgWiFiSSIDBroadcast=1&RgWiFiServiceChkBox=1&RgWiFiSSIDBroadcastChkBox=1&RgWiFiPrimSSID=jm&RgWiFiModeSelected=1&RgWiFiPowerOutputSelected=100&RgWiFiNBandWidthSelected=2&RgWiFiChannelSelected=0&PrimSecurityRadio=0&PrimSecurityRadioValue=0&GNSecurityRadioValue=0&PreSharedKey=QLBV66P1EF&PreSharedKey=&Wep128NetworkKey1=00000000000000000000000001&RgWiFiApplyConfigChanges=Appliquer" http://"$MODEM"/goform/WebUiRgWiFiConfig

wget -qO/dev/null http://"$MODEM"/logout.html
EOF
    chmod a+x /usr/local/bin/update_modem
  else
    echo "No LaBox MODEM found on IP $MODEM"
  fi
}

require_apache_php() {
if ! [ -d /etc/php5 ] || ! [ -d /etc/apache2 ]; then
  require_packages \
    apache2 \
    libapache2-mod-php5 \
    php5-cli \
    php5-apcu \
    php5-curl \
    php5-fpm \
    php5-gd \
    php5-imap \
    php5-pgsql
fi
generate_apache_conf
a2enmod proxy
a2enmod proxy_http
update_php_ini
}

require_postgresql() {
if ! [ -d /etc/postgresql ]; then
  require_packages \
    postgresql \
    postgresql-contrib
fi
}

install_bluetooth() {
  require_packages bluetooth
  cat > /etc/systemd/system/bluetooth_power.service <<EOF
[Unit]
Description=Enables bluetooth at boot

[Service]
Type=oneshot
ExecStart=/bin/bash -c '/usr/bin/bluetoothctl <<< "power on"'
User=root
Group=root

[Install]
WantedBy=bluetooth.service
EOF
  systemctl enable bluetooth_power
  systemctl start bluetooth_power
}

install_unison() {
  [ -d "$UNISON" ] || mkdir -p "$UNISON"
  unison_common_profile > "$UNISON/_common.prf"
}

upload_ssh_key() {
require_master
require_packages openssh-client
echo "Establishing SSH connection to $MASTER"
[ -e "$HOME/.ssh/id_rsa" ] || ssh-keygen -C "$(hostname) standby to $MASTER" -f "$HOME/.ssh/id_rsa" -N ''
echo "Uploading root public key to $MASTER_USER"
ssh "$MASTER_USER" "grep '$(<"$HOME/.ssh/id_rsa.pub")' \$HOME/.ssh/authorized_keys &>/dev/null || cat >> \$HOME/.ssh/authorized_keys" < "$HOME/.ssh/id_rsa.pub"
ssh "$MASTER_USER" "echo SSH connection successfully established"
}

install_synccluster_cron() {
cat > "/etc/cron.d/$SCRIPTNAME" <<EOF
24 4 * * * root /usr/local/bin/$SCRIPTNAME sync
*/20 * * * * root /usr/local/bin/$SCRIPTNAME quick_sync
EOF
}

external_backup() {
host="${1#*@}"
host="${host%%:*}"
path="${1#*:}"

# Setup SSH key
local oldmaster="$MASTER"
local oldmaster_user="$MASTER_USER"
MASTER="$host"
MASTER_USER="${1%%:*}"
upload_ssh_key

# Setup synchronization task
cat >> /etc/cron.d/"${SCRIPTNAME}_$host" <<EOF
05 3 * * * root rsync -a --delete '$1/' '$BACKUPDIR/$host/fs/$path/'
EOF
mkdir -p "$BACKUPDIR/$host/fs/$path/"

# Restore MASTER variables
MASTER="$oldmaster"
MASTER_USER="$oldmaster_user"

echo "External backup successfully set up"
}

periodic_backup() {
host="${1#*@}"
host="${host%%:*}"
path="${1#*:}"

# Setup SSH key
local oldmaster="$MASTER"
local oldmaster_user="$MASTER_USER"
MASTER="$host"
MASTER_USER="${1%%:*}"
upload_ssh_key

# Setup synchronization task
cat >> /etc/cron.d/"${SCRIPTNAME}_$host" <<EOF
05 3 * * * root /usr/local/bin/$SCRIPTNAME backup '$1' '$BACKUPDIR/$host'
EOF
mkdir -p "$BACKUPDIR/$host/fs/$path/"

# Restore MASTER variables
MASTER="$oldmaster"
MASTER_USER="$oldmaster_user"

echo "Periodic backup successfully set up"
}



fetch_backup_conf() {
local oldmaster="$MASTER"
local oldmaster_user="$MASTER_USER"
. "$1"
MASTER="$oldmaster"
MASTER_USER="$oldmaster_user"

generate_synccluster_conf
}

fetch_master_conf() {
local oldmaster="$MASTER"
local oldmaster_user="$MASTER_USER"
trap "rm -f /tmp/$SCRIPTNAME" EXIT
if rsync "$MASTER_USER:/etc/default/$SCRIPTNAME" "/tmp/$SCRIPTNAME"; then
  . "/tmp/$SCRIPTNAME"
  rm "/tmp/$SCRIPTNAME"
fi
trap EXIT
MASTER="$oldmaster"
MASTER_USER="$oldmaster_user"

generate_synccluster_conf
}

snapshot() {
  name="synccluster-snapshot-$1-$(date +%Y-%m-%d_%H-%M-%S)"
  mount | grep -E -e '^[^ ]* on / type btrfs ' -e '^[^ ]* on /home type btrfs ' | while read device on target type fs options; do
    while [ -e "$target/$name" ]; do
      name="$name.new"
    done
    btrfs subvolume snapshot "$target" "$target/$name"
  done
}

create_data_volume() {
  local mass="$1"
  local name="$2"
  local path
  if [ "$3" ]; then
    path="$(readlink -fs "$3")"
  else
    path=""
  fi
  local mountpoint="$DATADIR/$name"

  if [ -e "$mountpoint" ]; then
    mountpoint="$(readlink -fs "$mountpoint")"
  fi

  require_root
  require_domain

  local label="${DOMAIN}=$mass"

  local tmpdir="$(mktemp -d)"
  trap "umount -l '$tmpdir'; rmdir '$tmpdir'" EXIT
  
  mount -o subvol=/ "/dev/disk/by-label/$label" "$tmpdir"
  if grep -E "^LABEL=$label .*subvol=$name[, ]" "$tmpdir/fstab" &>/dev/null; then
    # Already exists
    echo "Data volume $name already declared in $mass"
    exit 1
  fi
  if ! [ -e "$tmpdir/$name" ]; then
    # The volume does not exist at all
    btrfs subvolume create "$tmpdir/$name"
  fi
  local fstab="LABEL=$label $mountpoint btrfs subvol=$name 0 0"
  echo "$fstab" >> "$tmpdir/fstab"
  echo "$fstab" >> /etc/fstab

  # Move existing path to the new volume
  if [ "$path" ]; then
    rsync -aP "$path/" "$tmpdir/$name/"
    rm -r "$path"
    [ "${mountpoint%/}" = "${path%/}" ] || ln -s "$mountpoint" "$path"
  fi

  mkdir -p "$mountpoint"
  mount "$mountpoint"

  umount -l "$tmpdir"
  rmdir "$tmpdir"

  trap EXIT
}

data_volume_backup() {
  local name="$1"
  local targetname="$2"
  local target="$3"
  local targetmass="$4"
  local mountpoint="$DATADIR/$name"
  local targetmountpoint
  local rsynctarget
  local host

  # Quick sanity check
  if ! mountpoint -q "$mountpoint"; then
    echo "$mountpoint not mounted, aborting"
    exit 1
  fi

  if [ "$target" ]; then
    host="${target#*@}"

    # Setup SSH key
    local oldmaster="$MASTER"
    local oldmaster_user="$MASTER_USER"
    MASTER="$host"
    MASTER_USER="$target"
    upload_ssh_key
    fetch_master_conf

    targetmountpoint="$M_DATADIR/$targetname"

    # Check that the remote server has the volume
    if ! master_exec mountpoint -q "$targetmountpoint"; then
      if [ "$targetmass" ]; then
        if ! master_exec create_data_volume "$targetmass" "$targetname"; then
          echo "Could not create volume $targetname on drive $targetmass on host $MASTER_USER"
          exit 1
        fi
      else
        echo "$targetmountpoint not mounted on $target, aborting"
        exit 1
      fi
    fi

    rsynctarget="$target:$targetmountpoint"
  else
    host="localhost"
    targetmountpoint="$DATADIR/$targetname"
    rsynctarget="$targetmountpoint"

    # Quick sanity check
    if ! mountpoint -q "$targetmountpoint"; then
      echo "$targetmountpoint not mounted, aborting"
      exit 1
    fi
  fi

  # Setup synchronization task
  cat >> /etc/cron.d/"${SCRIPTNAME}_$host" <<EOF
00 3 * * * root rsync -a --delete '$mountpoint/' '$rsynctarget/'
EOF
  
  # Restore MASTER variables
  MASTER="$oldmaster"
  MASTER_USER="$oldmaster_user"
  
  echo "External backup successfully set up"
}

unison_data_volume() {
  local name="$1"
  local targetname="$2"
  local target="$3"
  local targetmass="$4"
  local mountpoint="$DATADIR/$name"
  local targetmountpoint
  local rsynctarget
  local host

  # Quick sanity check
  if ! mountpoint -q "$mountpoint"; then
    echo "$mountpoint not mounted, aborting"
    exit 1
  fi

  host="${target#*@}"

  # Setup SSH key
  local oldmaster="$MASTER"
  local oldmaster_user="$MASTER_USER"
  MASTER="$host"
  MASTER_USER="$target"
  upload_ssh_key
  fetch_master_conf

  targetmountpoint="$M_DATADIR/$targetname"

  # Check that the remote server has the volume
  if ! master_exec mountpoint -q "$targetmountpoint"; then
    if [ "$targetmass" ]; then
      if ! master_exec create_data_volume "$targetmass" "$targetname"; then
        echo "Could not create volume $targetname on drive $targetmass on host $MASTER_USER"
        exit 1
      fi
    else
      echo "$targetmountpoint not mounted on $target, aborting"
      exit 1
    fi
  fi

  unisonname="volume_${name}_${host}_${targetname}"

  # Create unison profile
  cat > "$UNISON/$unisonname.prf" << EOF
include _common
root = $mountpoint
root = ssh://$MASTER_USER/$targetmountpoint
EOF

  # Create cron task
  cat >> /etc/cron.d/"${SCRIPTNAME}_$targethost" << EOF
00 3 * * * root UNISON='$UNISON' unison '$unisonname'
EOF

  # Restore MASTER variables
  MASTER="$oldmaster"
  MASTER_USER="$oldmaster_user"
}

create_data_drive() {
  local name="$1"
  local device="$2"

  require_root
  require_domain

  if ! [ -e "$device" ] || ! [ "$name" ]; then
    help
  fi

  echo "The device $device will be formatted, all data on it will be lost. Continue ? (yes/NO)"
  read answer
  if [ "$answer" != "yes" ]; then
    echo "Aborted."
    exit 1
  fi

  local label="${DOMAIN}=$name"

  mkfs.btrfs -f -L "$label" "$device"
}

unmount_data_volume() {
  local drive="$1"
  local name="$2"
  
  require_root
  require_domain

  local device="${DOMAIN}=$drive"
  local realdevice="$(readlink -fs "/dev/disk/by-label/$device")"

  if ! [ "$name" ] || ! [ "$drive" ]; then
    help
  fi

  fstabline="$(grep -E "^LABEL=$device .*[, ]subvol=$name[, ]" /etc/fstab)"

  if ! [ "$fstabline" ]; then
    echo "Subvolume $name could not be found in drive $drive. Aborting."
    exit 1
  fi

  echo "The subvolume $name of the drive $drive ($realdevice) will be unmounted and undeclared. Continue ? (yes/NO)"
  
  read answer
  if [ "$answer" != "yes" ]; then
    echo "Aborted."
    exit 1
  fi

  # Remove the entry in /etc/fstab
  read d mountpoint other <<< "$fstabline"
  grep -v -E "^LABEL=$device .*$mountpoint .*subvol=$name[, ]" /etc/fstab > /etc/fstab_ || true
  mv /etc/fstab_ /etc/fstab

  # Unmount the mount point
  umount -l "$mountpoint"

  umount -l "$tmpdir"
  rmdir "$tmpdir"
  trap EXIT
}

remove_data_volume() {
  local drive="$1"
  local name="$2"
  
  require_root
  require_domain

  local device="${DOMAIN}=$drive"
  local realdevice="$(readlink -fs "/dev/disk/by-label/$device")"

  if ! [ "$name" ] || ! [ "$drive" ]; then
    help
  fi

  fstabline="$(grep -E "^LABEL=$device .*[, ]subvol=$name[, ]" /etc/fstab)"

  if ! [ "$fstabline" ]; then
    echo "Subvolume $name could not be found in drive $drive. Aborting."
    exit 1
  fi

  echo "The subvolume $name of the drive $drive ($realdevice) will be deleted and all its data will be lost. Continue ? (yes/NO)"
  
  read answer
  if [ "$answer" != "yes" ]; then
    echo "Aborted."
    exit 1
  fi

  # Remove the entry in /etc/fstab
  read d mountpoint other <<< "$fstabline"
  grep -v -E "^LABEL=$device .*$mountpoint .*subvol=$name[, ]" /etc/fstab > /etc/fstab_ || true
  mv /etc/fstab_ /etc/fstab

  # Unmount the mount point
  umount -l "$mountpoint"

  # Remove the entry in the fstab of the drive
  local tmpdir="$(mktemp -d)"
  trap "umount -l '$tmpdir'; rmdir '$tmpdir'" EXIT
  mount -o subvol=/ "/dev/disk/by-label/$device" "$tmpdir"

  grep -v -E "^LABEL=$device .*$mountpoint .*subvol=$name[, ]" "$tmpdir/fstab" > "$tmpdir/fstab_" || true
  mv "$tmpdir/fstab_" "$tmpdir/fstab"
  btrfs subvolume delete "$tmpdir/$name"

  # Remove drive fstab if empty
  if [ "$(wc -l "$tmpdir/fstab" | cut -d' ' -f1)" -eq 0 ]; then
    rm "$tmpdir/fstab"
  fi

  umount -l "$tmpdir"
  rmdir "$tmpdir"
  trap EXIT
}

wipe_data_drive() {
  local name="$1"
  
  require_root
  require_domain

  local device="${DOMAIN}=$name"
  local realdevice="$(readlink -fs "/dev/disk/by-label/$device")"

  if ! [ "$name" ]; then
    help
  fi

  if ! [ -e "/dev/disk/by-label/$device" ]; then
    echo "Drive $name could not be found. Aborting."
    exit 1
  fi

  echo "The drive $name ($realdevice) will be deleted and all its data will be lost. Continue ? (yes/NO)"
  
  read answer
  if [ "$answer" != "yes" ]; then
    echo "Aborted."
    exit 1
  fi

  # Unmount all volumes of the drive
  grep -E "^LABEL=$device " /etc/fstab | while read d mountpoint other; do
    umount "$mountpoint"
  done

  # Remove all entries from the fstab
  grep -v -E "^LABEL=$device " /etc/fstab > /etc/fstab_ || true
  mv /etc/fstab_ /etc/fstab

  # Trash the device to remove all its data
  dd if=/dev/zero of="/dev/disk/by-label/$device" bs=1M count=64
}

require_root() {
  if [ "$UID" -ne 0 ]; then
    echo "This script requires to be root."
    exit 1
  fi
}

setup_master() {
  require_root

  echo "Set up this host as a master ? (y/n)"
  read answer
  [ "$answer" = "y" ] || exit 0

  ROLE=master

  snapshot before-setup-master

  require_domain
  require_password
  require_mailrelay

  install_synccluster
  generate_synccluster_conf

  install_base_packages
  install_postfix
  install_dovecot
  install_unison
  install_roundcube
  install_owncloud

  systemctl restart apache2
  systemctl restart postfix
  systemctl restart dovecot
}


unison_common_profile() {
cat <<'EOF'
path = Bureau
path = Documents
path = Images
path = Modèles
path = Musique
path = Vidéos
path = Jeux
path = Logiciels
path = .config
path = .mozilla
path = .vim
path = .ssh

batch = true
times = true
silent = true
retry = 1
addversionno = true
sshargs = -C

owner = true
times = true

prefer = newer

ignore = Regex .*/\.?[cC]ache/.*
ignore = Name [lL]ock
ignore = Name .parentlock
ignore = Name *.[lL]ock
ignore = Name *.nps
ignore = Name *.o
ignore = Name *~
ignore = Name .*~
ignore = Name .[tT]rash*
ignore = Name .*.swp
ignore = Name [Tt]humbs.db
ignore = Name $RECYCLE.BIN
ignore = Name Crash Reports
ignore = Path Documents/HTC
EOF
}

owncloud_conf_sync() {
  [ "$ROLE" != master ] || return

  local target="$WWWDIR/owncloud/config/config.php"
  local src="/tmp/config.php"

  require_master_conf

  trap "rm -f $src ${src}.tmp" EXIT

  rsync -a "$MASTER_USER:$M_WWWDIR/owncloud/config/config.php" "$src"
  grep -v -e "'instanceid'" -e "'passwordsalt'" -e "'secret'" -e "'version'" -e ');' "$target" > "${target}.tmp"
  grep -e "'instanceid'" -e "'passwordsalt'" -e "'secret'" -e "'version'" -e ');' "$src" >> "${target}.tmp"
  mv "${target}.tmp" "$target"

  trap EXIT
}

cloud_sync() {
  require_master_conf
  [ -z "$M_CLOUDDIR" ] || [ -z "$CLOUDDIR" ] || rsync -a --delete "$MASTER_USER:$M_CLOUDDIR/" "$CLOUDDIR/"
}

require_master() {
  [ "$MASTER_USER" ] || MASTER_USER="$1"
  [ "$MASTER_USER" ] || read -p 'Enter master user and host (example: root@master.domain.tld):' MASTER_USER
  MASTER="${MASTER_USER#*@}"
}

setup_standby() {

snapshot before-setup-standby

require_master "$1"

if [ "$UID" -ne 0 ]; then
  if which sudo &>/dev/null; then
    sudo "$@"
  else
    echo "This script requires to be root."
    exit 1
  fi
fi

echo "Set up this host as a standby to $MASTER ? (y/n)"
read answer
[ "$answer" = "y" ] || exit 0

ROLE=standby

require_password
install_base_packages

# Install synccluster on this machine
install_synccluster
generate_synccluster_conf
install_synccluster_cron

upload_ssh_key
fetch_master_conf
install_postfix
install_dovecot
install_unison
install_roundcube
install_owncloud

echo "Synchronize data with master"
sync
}

setup_secondary() {

snapshot before-setup-secondary

require_master "$1"

if [ "$UID" -ne 0 ]; then
  if which sudo &>/dev/null; then
    sudo "$@"
  else
    echo "This script requires to be root."
    exit 1
  fi
fi

echo "Set up this host as a secondary to $MASTER ? (y/n)"
read answer
[ "$answer" = "y" ] || exit 0

ROLE=secondary

require_password
install_base_packages

{
set +e
systemctl stop apache2
systemctl disable apache2

systemctl stop dovecot
systemctl disable dovecot

systemctl stop postfix
systemctl disable postfix
set -e
} || true

# Install synccluster on this machine
install_synccluster
generate_synccluster_conf
install_synccluster_cron

upload_ssh_key
fetch_master_conf
install_postfix
install_dovecot
install_unison

echo "Synchronize data with master"
sync
}

install_synccluster() {
  dir "/usr/local/bin"
  cp "$SCRIPT" "/usr/local/bin/$SCRIPTNAME" &>/dev/null || true
  chmod 755 "/usr/local/bin/$SCRIPTNAME"
}

user_sync() {
T="$(mktemp -d)"
trap "rm -rf '$T'" EXIT

rsync "$MASTER_USER:/etc/{passwd,shadow,group,gshadow}" "$T"/
cp /etc/passwd "$T"/passwd.new
cp /etc/shadow "$T"/shadow.new
cp /etc/group "$T"/group.new
cp /etc/gshadow "$T"/gshadow.new

# Merge user files

grep -E ":x:100[0-9][0-9]:" "$T/group" | while IFS=':' read group pass gid members; do
  # Add group if missing
  if ! grep -E "^$group:x:" "$T/group.new"; then
    grep -E "^$group:x:" "$T/group" >> "$T/group.new"
  fi
done

grep -E ":x:100[0-9][0-9]:" "$T/passwd" | while IFS=':' read user pass uid gid name homedir shell; do
  if [ "$ROLE" != secondary ] && [ "$ROLE" != roaming ]; then
    # Add user if missing
    if ! grep -E "^$user:" "$T/passwd.new" &>/dev/null; then
      grep -E "^$user:" "$T/passwd" >> "$T/passwd.new"

      # Add user to the same groups as local user
      sed -i 's;\(.*:x:[0-9]*.*[:,]local.*\);\1,'"$user"';' "$T/group.new"

      # Create home directory from skeleton
      if ! [ -d "$homedir" ]; then
        cp -a /etc/skel "$homedir"
        chown -R "$uid:$gid" "$homedir"
      fi
    fi

    if grep -E "^$user:" "$T/passwd.new" &>/dev/null; then
      # Update unison profile
      if [ "$UNISON" ]; then
        cat > "$UNISON/$user.prf" << EOF
include _common
root = /home/$user
root = ssh://$MASTER_USER/$homedir
EOF
      fi
    fi
  fi

  # Update password
  grep -vE "^$user:" "$T/shadow.new" > "$T/shadow.new."
  grep -E "^$user:" "$T/shadow" >> "$T/shadow.new."
  mv "$T/shadow.new." "$T/shadow.new"

  echo "$user"
done

# Update sudoers
if grep -E "^sudo:x:" &>/dev/null "$T/group.new"; then
  grep -vE "^sudo:x:" "$T/group.new" > "$T/group.new."
  sudoers="$(grep -E "^sudo:x:" "$T/group.new" | cut -d: -f1-3):"
  while read user; do
    if grep -E "^$user:x:100[0-9][0-9]:" "$T/passwd.new"; then
      sudoers="$sudoers$user,"
      break
    fi
  done <<< "$(cat "$T/group" | cut -d: -f4 | tr ',' '\n')"
  echo "${sudoers:0: -1}" >> "$T/group.new." # Remove trailing comma
  mv "$T/group.new." "$T/group.new"
fi

cp "$T/gshadow" "$T/gshadow.new"

# Update system files
mv "$T/passwd.new" /etc/passwd
mv "$T/shadow.new" /etc/shadow
mv "$T/group.new" /etc/group
chown root:root /etc/passwd /etc/shadow /etc/group
chmod 644 /etc/passwd /etc/group
chmod 600 /etc/shadow

# Remove obsolete users
grep -E ":x:100[0-9][0-9]:" /etc/passwd | while IFS=':' read user pass uid gid name homedir shell; do
  if ! grep -E "^$user:" "$T"/passwd; then
    echo "User $user was removed. Home directory left untouched."
    rm -f "$UNISON/$user.prf"
    userdel "$user"
  fi
done

# Synchronize crontabs
dir /var/spool/cron/crontabs.master
rsync -a "$MASTER_USER":/var/spool/cron/crontabs/ /var/spool/cron/crontabs.master/

rm -rf "$T"
trap EXIT
}

unison_sync() {
  [ "$UNISON" ] || return
  require_master_conf

  # Synchronize content
  for f in "$UNISON"/[a-zA-Z0-9]*.prf; do
    user="$(basename "$f" .prf)"
    if grep -E "^$user:" /etc/passwd &>/dev/null; then
      unison "$user"
    fi
  done
}

postgres_sync() {
  pushd / &>/dev/null
  ssh "$MASTER_USER" \
      "cd /; su -c 'pg_dumpall -c | xz -c -6' postgres" \
    | su -c 'unxz -c | grep -Pv "^(?:CREATE|DROP|ALTER) ROLE postgres" | psql -q' postgres >/dev/null
  popd &>/dev/null
}

conf_sync() {
  require_master_conf
  if [ "$ROLE" = secondary ]; then
    rsync -a --delete "$MASTER_USER:/etc/{apache2,php5,postfix,dovecot}" /etc/
    rsync -a --delete "$MASTER_USER:$M_WWWDIR/roundcubemail/config/" "$WWWDIR/roundcubemail/config/"
    rsync -a --delete "$MASTER_USER:$M_WWWDIR/owncloud/config/" "$WWWDIR/owncloud/config/"
    [ -z "$M_UNISON" ] || [ -z "$UNISON" ] || rsync -a --delete "$MASTER_USER:$M_UNISON/" "$UNISON"/
    cert_sync
  else
    owncloud_conf_sync
  fi
}

cert_sync() {
  rsync -a "$MASTER_USER":/etc/ssl/certs/ssl-cert-snakeoil.pem /etc/ssl/certs/ssl-cert-snakeoil.pem
  rsync -a "$MASTER_USER":/etc/ssl/private/ssl-cert-snakeoil.key /etc/ssl/private/ssl-cert-snakeoil.key
  rsync -a "$MASTER_USER":/etc/ssh/ssh_host_* /etc/ssh/
}

mail_sync() {
  require_master_conf
  rsync -a --delete "$MASTER_USER":"$M_MAILDIR"/ "$MAILDIR"/
  rsync -a "$MASTER_USER":/etc/aliases /etc/aliases
  newaliases
}

install_drives() {
require_domain
require_packages btrfs-tools

local pattern=''
if [ "$1" = "-a" ]; then
  pattern="*"
else
  pattern="$DOMAIN=*"
fi

tmpdir="$(mktemp -d)"

pushd /dev/disk/by-label &>/dev/null
for d in $pattern; do
  trap "rm -f /tmp/fstab; umount '$tmpdir'; rmdir '$tmpdir'" EXIT
  mount -r "$d" "$tmpdir" || continue
  if [ -e "$tmpdir/fstab" ]; then
    grep -F -f <(cut -d' ' -f1 "$tmpdir/fstab") -v /etc/fstab > /tmp/fstab
    cat "$tmpdir/fstab" >> /tmp/fstab
    mv /tmp/fstab /etc/fstab
    cp "$tmpdir/fstab" "/tmp/fstab"
    umount "$tmpdir"
    while read device mountpoint other; do
      if [ -e "$mountpoint" ]; then
        if ! [ -d "$mountpoint" ]; then
          echo "Warning: $mountpoint is not empty"
          continue
        fi
      else
        mkdir -p "$mountpoint"
      fi
      echo "Mounting $mountpoint from device $device"
      mount "$mountpoint"
    done < "/tmp/fstab"
  fi
  trap EXIT
done
popd &>/dev/null

rm -r "$tmpdir"
trap EXIT
}

sync() {
  update_from_master
  quick_sync
  case "$ROLE" in
    standby)
      postgres_sync
      cloud_sync
      mail_sync
      conf_sync
      systemctl restart apache2
      systemctl restart postfix
      systemctl restart dovecot
      ;;
    secondary)
      postgres_sync
      cloud_sync
      mail_sync
      conf_sync
      cert_sync
      ;;
    client)
      ;;
    roaming)
      ;;
  esac
}

quick_sync() {
  case "$ROLE" in
    standby)
      user_sync
      unison_sync
      ;;
    secondary)
      user_sync
      unison_sync
      ;;
    client)
      user_sync
      ;;
    roaming)
      user_sync
      unison_sync
      ;;
  esac
}

install_nfs_server() {
  require_packages nfs-kernel-server
  cat > /etc/exports <<EOF
/home 192.168.0.0/24(rw,sync,no_subtree_check,no_root_squash,crossmnt,fsid=0)
EOF
  exportfs -r
}

install_nfs_client() {
  require_master "$1"
  require_packages nfs-common
  require_master_conf
  grep -v ' nfs4 ' /etc/fstab > /tmp/fstab
  cat >> /tmp/fstab <<EOF
$MASTER:/ /home nfs4 rw,rsize=131072,wsize=131072 0 0
EOF
  mv /tmp/fstab /etc/fstab
}

promote() {
echo "This host will be promoted to a master server."
echo "Ensure that the previous master is disabled before proceeding."
echo "This cannot be undone. Continue ?"
read answer
[ "$answer" != "yes" ] && exit 0

if [ -z "$MASTER" ]; then
  echo "This host is already a master. Cannot continue."
  exit 1
fi

snapshot before-promote

# Try to disable the current master
master_exec "systemctl disable apache2; systemctl disable dovecot; systemctl disable postfix" || true

# Mail relay may be different for this new master, so adjust it.
read -i "$MAILRELAY" -p 'Mail relay of the new master:' MAILRELAY
sed -i "s;^relayhost *=.*;relayhost = $MAILRELAY;" /etc/postfix/main.cf

# Promote as master
unset MASTER
unset MASTER_USER
generate_synccluster_conf

# Start services
systemctl enable apache2
systemctl start apache2

systemctl enable dovecot
systemctl start dovecot

systemctl enable postfix
systemctl restart postfix

# Disable backup cron tasks
rm "/etc/cron.d/$SCRIPTNAME"

# Remove backup profiles for unison
for f in "$UNISON"/[a-zA-Z0-9]*.prf; do
  rm "$f"
done

# Enable user contabs
mv /var/spool/cron/crontabs.master/* /var/spool/cron/crontabs
}

install_owncloud_client() {
  echo "deb http://download.opensuse.org/repositories/isv:/ownCloud:/desktop/Debian_$(cut -c1 /etc/debian_version).0/ /" >> /etc/apt/sources.list.d/owncloud-client.list 
  wget -qO- "http://download.opensuse.org/repositories/isv:ownCloud:desktop/Debian_$(cut -c1 /etc/debian_version).0/Release.key" | apt-key add -
  apt-get update
  require_packages owncloud-client
}

setup_client() {
  require_master "$1"
  snapshot before-setup-client
  install_synccluster
  UNISON=
  ROLE=client
  generate_synccluster_conf
  upload_ssh_key
  install_owncloud_client
  install_nfs_client
  install_synccluster_client_sync
  sync
}

setup_roaming() {
  require_master "$1"
  snapshot before-setup-roaming
  install_synccluster
  ROLE=roaming
  generate_synccluster_conf
  upload_ssh_key
  install_owncloud_client
  install_synccluster_client_sync
  sync
}

install_kodi() {
  snapshot before-install-kodi
  require_password
  require_packages kodi lightdm

  cat > /usr/local/bin/kodi_session <<EOF
#!/bin/bash

(sleep 15 && /usr/bin/bluetoothctl <<< "power on" ) &
/usr/bin/setxkbmap fr
EOF
  chmod +x /usr/local/bin/kodi_session

  useradd -c "" -d "$KODIDIR" -p"${PASSWORD}kodi" -U kodi

  grep "$SCRIPTNAME configuration" /etc/lightdm/lightdm.conf &>/dev/null || mv /etc/lightdm/lightdm.conf /etc/lightdm/lightdm.conf.old 
  cat > /etc/lightdm/lightdm.conf <<EOF
# $SCRIPTNAME configuration
[LightDM]
start-default-seat=true
seats=Seat:0

[SearDefaults]

[Seat:0]
xdg-seat=seat0
allow-user-switching=false
autologin-user=kodi
autologin-user-timeout=0
enabled=true
display-setup-script=/usr/local/bin/kodi_session
EOF
}

# Run a command on the master
master_exec() {
  set +e
  local rv
  if [ "$MASTER" ]; then
    ssh "$MASTER_USER" "$SCRIPTNAME master_exec" "$@"
    rv="$?"
  else
    "$@"
    rv="$?"
  fi
  set -e
  return $rv
}

# Run a command on this host, and all its masters
recursive_exec() {
  set +e
  local rv
  if [ "$MASTER" ]; then
    ssh "$MASTER_USER" "$SCRIPTNAME recursive_exec" "$@"
    rv="$?"
  fi
  if [ "$rv" -eq 0 ]; then
    "$@"
    rv="$?"
  fi
  set -e
  return rv;
}

user_add() {
  login="$1"
  name="$2"
  group="$3"

  if ( [ "$ROLE" = secondary ] || [ "$ROLE" = roaming ] ) && [ "$login" ] && ! [ "$name" ] && ! [ "$group" ]; then
    # Add a user already existing on the master
    local newuser="$(master_exec grep -E "$login:x:100[0-9][0-9]:" /etc/passwd 2>/dev/null)"
    if [ "$newuser" ]; then
      echo "$newuser" >> /etc/fstab
      user_sync
    else
      echo "User $login does not exist on the master"
      exit 1
    fi
  else
    [ "$login" ] && [ "$name" ] && [ "$group" ] || help

    newuid="$(cut -d: -f3 /etc/passwd | grep -E '100[0-9][0-9]'|sort -nr)"
    [ "$newuid" ] && newuid="$((newuid + 1))" || newuid=10000

    master_exec useradd -c '' -d /home/$login -m -N -u $newuid $login
    recursive_exec user_sync
  fi
}

user_add_to() {
  login="$1"
  group="$2"
  [ "$login" ] && [ "$group" ] || help

  master_exec usermod -a -G $group $login
  recursive_exec user_sync
}

user_del() {
  login="$1"
  # TODO remove home, cloud and roundcube data
  master_exec userdel -r $login
  recursive_exec user_sync
}

group_add() {
  group="$1"
  [ "$group" ] || help

  newgid="$(cut -d: -f3 /etc/group | grep -E '100[0-9][0-9]'|sort -nr)"
  [ "$newgid" ] && newgid="$((newgid + 1))" || newgid=10000

  master_exec groupadd -g $newgid $group
  recursive_exec user_sync
}

group_del() {
  group="$1"
  master_exec groupdel -r $group
  recursive_exec user_sync
}

# Show info about the host
info() {
require_root
if ! [ -e "/etc/default/$SCRIPTNAME" ]; then
  echo "$SCRIPTNAME is not installed on this machine"
  exit 1
fi
require_domain
if [ -z "$MASTER" ]; then
  echo "Master server"
else
  echo "Linked to master server $MASTER"
fi

echo ""
echo ""
echo "Users:"
grep -E ':x:100[0-9][0-9]:' /etc/passwd | while IFS=: read user other; do
  echo " $user"
done
echo ""
echo ""
echo "Groups:"
grep -E ':x:100[0-9][0-9]:' /etc/group | while IFS=: read group other; do
  echo " $group"
done
echo ""
echo ""
echo "Mass storage:"
echo ""

pushd /dev/disk/by-label &>/dev/null
local tmpdir="$(mktemp -d)"
trap "umount -l '$tmpdir'; rmdir '$tmpdir'" EXIT
for d in "${DOMAIN}"=*; do

  name="${d#*=}"
  realdevice="$(readlink -fs "/dev/disk/by-label/$d")"

  mount "$d" "$tmpdir"
  read device total used available percent mp <<< "$(df -h "$tmpdir" | tail -1)"

  echo "  Device $name ($realdevice):"
  echo "    Used: $used ($percent)   Free: $available"

  if ! [ -e "$tmpdir/fstab" ]; then
    echo "    No subvolume"
    echo ""
    umount "$tmpdir"
    continue
  fi

  while read device mountpoint filetype options dump pass; do
    subvol="$(sed 's;.*subvol=\([^ ,]*\);\1;' <<< "$options")"
    mounted='not declared'
    if grep -E "$device.*$mountpoint.*$filetype" /etc/fstab &>/dev/null; then
      mount | grep -F " $mountpoint " &>/dev/null && mounted=mounted || mounted='not mounted'
    fi
    echo "    Subvolume $subvol on $mountpoint ($mounted)"
  done < "$tmpdir/fstab"

  umount "$tmpdir"
  echo ""
done
rmdir "$tmpdir"
trap EXIT
popd &>/dev/null
}

help() {
  cat <<EOF
$SCRIPTNAME: Setup and manage synchronization between different hosts.
The following commands are available:

$SCRIPTNAME setup_master
    Setup this machine as a new master.

$SCRIPTNAME setup_standby root@host.domain.tld
    Setup this machine as a standby to another machine.

$SCRIPTNAME setup_client root@host.domain.tld
    Setup this machine as a client of another machine (either a master or a standby).

$SCRIPTNAME setup_roaming root@host.domain.tld
    Setup this machine as a roaming client.

$SCRIPTNAME promote
    Promote the current standby as a master.
    This cannot be undone.

$SCRIPTNAME setup_sudo
    Setup the sudo utility to allow normal users to gain superuser privileges.

$SCRIPTNAME install_bluetooth
    Setup bluetooth power on boot

$SCRIPTNAME install_upnpc
    Setup UPNP broadcaster to open external ports on this machine

$SCRIPTNAME install_modem
    Install LaBox MODEM autoconfiguration. Warning: opens passwordless WiFi.

$SCRIPTNAME install_drives
    Autodetect and install all drives following the convention:
     Partition label = domain.example.tld.partlabel
     Contains a /fstab file that is appened to /etc/fstab

$SCRIPTNAME create_data_drive <name> <device>
    Format a data drive with the correct filesystem and label.
    Warning: all data on this drive is wiped.

$SCRIPTNAME create_data_volume <drive> <volume> [<path>]
    Create a volume on the specified drive.
    If <path> is set, move data from <path> to the new volume and create a symlink to it.
    Data move is not atomic, ensure that nobody can access it during the operation.

$SCRIPTNAME unmount_data_volume <drive> <volume>
    Unmount and uninstall a volume. Data will be kept on the drive and can be reinstalled with install_drives.

$SCRIPTNAME remove_data_volume <drive> <volume>
    Remove a volume from a drive.
    The volume will be unmounted, uninstalled and deleted permanently.

$SCRIPTNAME wipe_data_drive <drive>
    Remove all data from a drive and wipe its content.
    All mounted volumes will be unmounted before proceeding.

$SCRIPTNAME install_kodi
    Install the kodi media center as autoboot.
    Once installed, the PC will autologin to the kodi media center.

$SCRIPTNAME backup [source] [target]
    Backup a whole machine from source to target. source or target may be a remote path (root@host:/) but not both.
    By default, backup the local machine to the local backup directory.

$SCRIPTNAME restore_master <source>
    Create a new master on this host and restore data from a backup. <source> must point at a directory created with the backup command.
    <source> may be a local or a remote path.

$SCRIPTNAME periodic_backup <source>
    Setup a periodic backup of the remote server.
    Example: periodic_backup remote.host.example.tld:/

$SCRIPTNAME external_backup <source>
    Setup a periodic backup of a raw rsync path.

$SCRIPTNAME data_volume_backup <localvolume> <backupvolume> [user@host] [targetmass]
    Setup a cron job to backup a data volume to another. Uses rsync --delete.
    If user@host is omitted, does a local copy.

$SCRIPTNAME unison_data_volume <localvolume> <backupvolume> <user@host> [targetmass]
    Setup a unison job to synchronize a data volume across

$SCRIPTNAME user_add <username> <realname> <group>
    Add a new user. If executed from a standby or a client, creates the user on the master.

$SCRIPTNAME user_add_to <username> <group>
    Add a user to a group. Propagates to the master.

$SCRIPTNAME group_add <groupname>
    Add a new group. If executed from a standby or a client, creates the group on the master.

$SCRIPTNAME user_del <username>
    Removes a user and ALL ITS DATA. If executed from a standby or a client, deletes the user and its data on the master.

$SCRIPTNAME group_del <groupname>
    Remove a group. If executed from a standby or a client, removes the group on the master.

$SCRIPTNAME user_sync
    Synchronize users.

$SCRIPTNAME sync
    Synchronize data.

$SCRIPTNAME quick_sync
    Differential update to data sync.

$SCRIPTNAME owncloud_sync
    Synchronize owncloud configuration.

$SCRIPTNAME cert_sync
    Synchronize SSL certificate and SSH host key.

$SCRIPTNAME master_exec <command...>
    Executes a command on the master. Finds recursively the real master (a machine with no master) before running the command.
    This allows to run commands on the real top master, going through clients connected to standbys connected to a master.

$SCRIPTNAME recursive_exec <command...>
    Executes a command on all masters and on this host, recursively.
    The commands are executed on the topmost master first, then down to this host in the tree.
    Note that other clients and standbys are not impacted, since they are not known by their masters.

$SCRIPTNAME update_from_master
    Updates the local script to the version present on the master server.
    Automatically called on each full data sync.

$SCRIPTNAME info
    Show information about the current machine.
EOF
  exit 0
}

if [ -z "$1" -o "$1" = "-h" -o "$1" = "--help" ]; then
  help
fi


function="$1"; shift || true
"$function" "$@"
